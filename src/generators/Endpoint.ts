/**
 * Endpoint template generator.
 */
import inquirer from 'inquirer';
import chalk from 'chalk';
import { javascript } from '../utils';
import * as fs from 'fs';
import { promisify } from 'util';
import * as path from 'path';
import * as crypto from 'crypto';

export function randomHex() {
  return crypto.createHash('md5').update(new Date().toString()).digest('hex');
}

const readdir = promisify(fs.readdir);
const readFile = promisify(fs.readFile);
const stat = promisify(fs.stat);
const mkdir = promisify(fs.mkdir);
const writeFile = promisify(fs.writeFile);

/**
 * Returns a list of directory names only.
 * @param from The root to get the list from.
 * @returns A filtered list of directory names.
 */
export async function getDirsOnly(from: string) {
  const dirs = await readdir(from);
  const out: string[] = [];
  for (const dir of dirs) {
    const stats = await stat(path.join(from, dir));
    if (stats.isDirectory()) {
      out.push(dir);
    }
  }
  return out;
}

/**
 * Backtick character, for easier escaping.
 */
const backtick = '`';

export type HTTPMethod = 'POST' | 'PUT' | 'DELETE' | 'GET';

export interface ControllerData {
  method: HTTPMethod;
  path: string;
  description: string;
}

export interface Model {
  name: string;
  attributes: {
    name: string;
    type?: string;
    model?: string;
    required?: boolean;
    min?: number;
    max?: number;
  }[];
}

const NUMERIC = ['integer', 'float', 'double', 'number', 'real'].reduce(
  (o, n) => ({ ...o, [n]: n }),
  {}
);

/**
 * A list of gathered models.
 */
const models: Record<string, Model> = {};

const dataSize = [...Array(1).keys()];

/**
 * Generates the attribute string value.
 * @param attrib
 * @returns
 */
function resolveAttribute(attrib: Model['attributes'][0], level: number) {
  if (attrib.type === 'string') {
    return `"string_${randomHex()}"`;
  } else if (attrib.type === 'text') {
    return `"text_${randomHex()}"`;
  } else if (attrib.type in NUMERIC) {
    const value = Math.round(Math.random() * 105845684);
    if (value > attrib.max) {
      return attrib.max.toString();
    } else if (value < attrib.min) {
      return attrib.min.toString();
    }
    return value.toString();
  } else if (attrib.type === 'datetime') {
    return new Date().toISOString();
  } else if (attrib.model != null && level < 4) {
    return expandModel(attrib.model, level + 1);
  } else {
    return `null`;
  }
}

/**
 * Expands a model as random source code.
 * @param name The name of the model
 * @returns The code generated by the model, with arbitrary data.
 */
export function expandModel(name: string, level = 0): string {
  const model = models[name];
  if (model == null) {
    console.log(
      chalk.red`Model "${name}" not found, this will expand as an empty object.`
    );
    return '{}';
  }
  return (
    ' '.repeat(level) +
    '{\n' +
    model.attributes
      .map(attrib => `${attrib.name}: ${resolveAttribute(attrib, level)}`)
      .map(s => '  '.repeat(level + 1) + s)
      .join(',\n') +
    '\n' +
    '  '.repeat(level) +
    '}'
  );
}

/**
 * Tries to get all the model data of the whole directory.
 */
export async function getAllModels(list: string[]) {
  for (const dir of list) {
    try {
      const fp = path.join(API_DIRECTORY, dir);
      const modelPath = path.join(fp, 'models', `${dir}.settings.json`);
      const modelData = JSON.parse((await readFile(modelPath)).toString());
      console.log(
        chalk.gray`Found ${dir} model (${
          Object.keys(modelData.attributes).length
        } attributes)`
      );
      models[dir] = {
        name: dir,
        attributes: Object.keys(modelData.attributes).map(key => {
          const attrib = modelData.attributes[key];
          return {
            name: key,
            type: attrib.type,
            model: attrib.model,
          };
        }),
      };
    } catch (_) {
      console.log(chalk.gray(_));
      console.log(
        chalk.red`Could not get ${dir} model data, this might lead to incorrect data generation.`
      );
    }
  }
}

/**
 * Compiles the template and generates the test based on parameters.
 * @param name
 */
export async function generateTest(
  name: string,
  model: Model,
  permissions: string[],
  controllers: ControllerData[],
  useJWT: boolean
) {
  const prettyName = name[0].toUpperCase() + name.slice(1);
  const perms = permissions
    .map(p => `      'permissions.application.controllers.${name}.${p}'`)
    .join(',\n');
  const mockData = dataSize.map(() => expandModel(model.name, 1)).join(',\n');
  const expected = model.attributes
    .map(param => {
      if (param && param.model == null) {
        return `expect(response.body.${param.name}).toBe(data[0].${param.name})`;
      } else {
        return false;
      }
    })
    .filter(s => s)
    .map(s => `        ${s}`)
    .join('\n');
  const testCode = controllers
    .map(c => {
      return javascript`
  it('should ${c.description} (${c.method} ${c.path})', async (done) => {
    await request(strapi.server)
      .${c.method.toLowerCase()}('${c.path}')${
        c.method === 'GET' ? '' : `\n      .send(data[0])`
      }${
        useJWT
          ? `
      .set('Authorization', 'Bearer ' + jwt)`
          : ''
      }
      .expect(200)
      .expect('Content-Type', /json/)
      .then((response) => {
        expect(response.body).toBeDefined()
${expected}
      })

    done()
  })
`;
    })
    .join('');
  // TEMPLATE START //
  return javascript`
const request = require('supertest')
const { grantPrivileges } = require('../helpers/strapi')

const data = [
${mockData}
];
${
  useJWT
    ? `
let jwt // JWT Token for session
`
    : ''
}
describe('${prettyName}', () => {
  beforeAll(async (done) => {
${
  useJWT
    ? `
    const user = await strapi.plugins['users-permissions'].services.user.fetch({
      username: 'tester2',
      email: 'tester2@strapi.com',
    })
    jwt = strapi.plugins['users-permissions'].services.jwt.issue({
      id: user.id,
    })
`
    : ''
}
    permissions = [
${perms}  ]
    await grantPrivileges(${useJWT ? 'user.role.id' : 2}, permissions)
    done()
  })
  ${testCode}
})  
`;
  // TEMPLATE END //
}

/**
 * Yields a list of key+value pairs from object.
 */
export function pairs(obj: Record<string, any>) {
  return Object.keys(obj).map(k => [k, obj[k]]);
}

export async function inferPermissions(from: string) {
  const fp = path.join(from, 'config', 'routes.json');
  try {
    const data = JSON.parse((await readFile(fp)).toString());
    return data.routes.map((r: any) => (r.handler as string).split('.')[1]);
  } catch (_) {
    console.log(chalk.yellow`Couldn't infer permissions`);
    return [];
  }
}

/**
 * The API directory where controller data is stored.
 */
const API_DIRECTORY = '../api';

/**
 * Attempts to generate the passed controller list.
 * This function will attempt to infer the maximum information based
 * on API documentation.
 * @param list A list of controllers.
 */
export async function generateAll(list: string[]) {
  const { useJWT } = await inquirer.prompt<{ useJWT: boolean }>([
    {
      type: 'confirm',
      default: true,
      message: 'Generate JWT token code?',
      name: 'useJWT',
    },
  ]);
  for (const dir of list) {
    const fp = path.join(API_DIRECTORY, dir);
    const docPath = path.join(fp, 'documentation', '1.0.0', `${dir}.json`);
    const docs = JSON.parse((await readFile(docPath)).toString());
    try {
      await mkdir(dir);
    } catch (_) {
      console.log(chalk.gray`  Already exists`);
    }
    const cData = pairs(docs.paths)
      .map(([url, v]) => {
        return pairs(v).map(([method, c]) => {
          let description = '';
          if (c.responses['200'] != null) {
            description = c.responses['200'].description || '';
          }
          return {
            path: url,
            method: method.toUpperCase(),
            description,
          } as ControllerData;
        });
      })
      .flat();
    console.log(chalk.gray`Inferring permissions from ${dir} routes...`);
    const perms = await inferPermissions(fp);
    const m = models[dir] || { name: 'unknown', attributes: [] };
    const out = await generateTest(dir, m, perms, cData, useJWT);
    const outPath = path.join(dir, 'index.js');
    await writeFile(outPath, out);
    console.log(`âœ… Generated ${dir} test stub`);
  }
  console.log(chalk.greenBright`ðŸš€ Done! Check new tests!`);
}

/**
 * Generates the endpoint.
 */
export default async function endpoint() {
  console.log(
    chalk.gray`The generator will attempt to acquire the available API controllers...`
  );
  let toGenerate: string[] = [];
  try {
    const dirs = await getDirsOnly(API_DIRECTORY);
    const { included } = await inquirer.prompt([
      {
        type: 'checkbox',
        choices: dirs,
        name: 'included',
        message: 'Select the ones to include in the generation:',
        default: dirs.filter(dir => {
          try {
            fs.statSync(path.join(dir, 'index.js'));
            return false;
          } catch (_) {
            return true;
          }
        }),
      },
    ]);
    toGenerate = included;
  } catch (err) {
    if (typeof err.code === 'undefined') {
      throw err;
    }
    console.log(chalk.red`Couldn't locate the API directory`);
    const { included } = await inquirer.prompt([
      {
        type: 'input',
        message: 'Enter a comma separated list of directories:',
      },
    ]);
    toGenerate = included.split(',').map((s: string) => s.trim());
  }
  // Generate all
  await getAllModels(await getDirsOnly(API_DIRECTORY));
  await generateAll(toGenerate);
}
