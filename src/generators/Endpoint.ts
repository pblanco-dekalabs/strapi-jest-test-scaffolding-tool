/**
 * Endpoint template generator.
 */
import inquirer from 'inquirer';
import chalk from 'chalk';
import { javascript } from '../utils';
import * as fs from 'fs';
import { promisify } from 'util';
import * as path from 'path';
import * as crypto from 'crypto';

export function randomHex() {
  return crypto.createHash('md5').update(new Date().toString()).digest('hex');
}

const readdir = promisify(fs.readdir);
const readFile = promisify(fs.readFile);
const stat = promisify(fs.stat);
const mkdir = promisify(fs.mkdir);
const writeFile = promisify(fs.writeFile);

/**
 * Returns a list of directory names only.
 * @param from The root to get the list from.
 * @returns A filtered list of directory names.
 */
export async function getDirsOnly(from: string) {
  const dirs = await readdir(from);
  const out: string[] = [];
  for (const dir of dirs) {
    const stats = await stat(path.join(from, dir));
    if (stats.isDirectory()) {
      out.push(dir);
    }
  }
  return out;
}

/**
 * Backtick character, for easier escaping.
 */
const backtick = '`';

export type HTTPMethod = 'POST' | 'PUT' | 'DELETE' | 'GET';

export interface ControllerData {
  method: HTTPMethod;
  path: string;
  description: string;
}

export interface Model {
  name: string;
  attributes: {
    name: string;
    type?: string;
    model?: string;
    required?: boolean;
  }[];
}

/**
 * A list of gathered models.
 */
const models: Record<string, Model> = {};

const dataSize = [...Array(1).keys()];

/**
 * Expands a model as random source code.
 * @param name The name of the model
 * @returns The code generated by the model, with arbitrary data.
 */
export function expandModel(name: string, level = 0): string {
  const model = models[name];
  if (model == null) {
    console.log(
      chalk.red`Model "${name}" not found, this will expand as an empty object.`
    );
    return '{}';
  }
  return (
    ' '.repeat(level) +
    '{\n' +
    model.attributes
      .map((attrib) => {
        if (attrib.type === 'string') {
          return `${attrib.name}: "string_${randomHex()}"`;
        } else if (attrib.type == 'number') {
          return (
            attrib.name +
            ': ' +
            Math.round(Math.random() * 105845684).toString()
          );
        } else if (attrib.model != null && level < 4) {
          return attrib.name + ': ' + expandModel(attrib.model, level + 1);
        } else {
          return `${attrib.name}: null`;
        }
      })
      .map((s) => '  '.repeat(level + 1) + s)
      .join(',\n') +
    '\n' +
    '  '.repeat(level) +
    '}'
  );
}

/**
 * Tries to get all the model data of the whole directory.
 */
export async function getAllModels(list: string[]) {
  for (const dir of list) {
    try {
      const fp = path.join(API_DIRECTORY, dir);
      const modelPath = path.join(fp, 'models', `${dir}.settings.json`);
      const modelData = JSON.parse((await readFile(modelPath)).toString());
      console.log(
        chalk.gray`Found ${dir} model (${
          Object.keys(modelData.attributes).length
        } attributes)`
      );
      models[dir] = {
        name: dir,
        attributes: Object.keys(modelData.attributes).map((key) => {
          const attrib = modelData.attributes[key];
          return {
            name: key,
            type: attrib.type,
            model: attrib.model,
          };
        }),
      };
    } catch (_) {
      console.log(chalk.gray(_));
      console.log(
        chalk.red`Could not get ${dir} model data, this might lead to incorrect data generation.`
      );
    }
  }
}

/**
 * Compiles the template and generates the test based on parameters.
 * @param name
 */
export async function generateTest(
  name: string,
  model: Model,
  permissions: string[],
  controllers: ControllerData[]
) {
  const prettyName = name[0].toUpperCase() + name.slice(1);
  const perms = permissions
    .map((p) => `      'permissions.application.controllers.${name}.${p}'`)
    .join(',\n');
  const mockData = dataSize.map(() => expandModel(model.name, 1)).join(',\n');
  const expected = model.attributes
    .map((param) => {
      if (param && param.model == null) {
        return `expect(response.body.${param.name}).toBe(data[0].${param.name})`;
      } else {
        return false;
      }
    })
    .filter((s) => s)
    .map((s) => `        ${s}`)
    .join('\n');
  const testCode = controllers
    .map((c) => {
      return javascript`
  it('should ${c.description} (${c.method} ${c.path})', async (done) => {
    await request(strapi.server)
      .post('${c.path}')
      .send(data[0])
      .expect('Content-Type', /json/)
      .expect(200)
      .then((response) => {
        // TODO: Refine test data, generated from ${model.name} model.
        // WARN: It might contain inaccurate tests.
        expect(response.body).toBeDefined()
${expected}
      })

    done()
  })
`;
    })
    .join('');
  // TEMPLATE START //
  return javascript`
const request = require('supertest')
const { grantPrivileges } = require('../helpers/strapi')

const data = [
${mockData}
];

describe('${prettyName}', () => {
  beforeAll(async (done) => {
    permissions = [
${perms}  ]
    await grantPrivileges(2, permissions)

    done()
  })
  ${testCode}
})  
`;
  // TEMPLATE END //
}

/**
 * Yields a list of key+value pairs from object.
 */
export function pairs(obj: Record<string, any>) {
  return Object.keys(obj).map((k) => [k, obj[k]]);
}

export async function inferPermissions(from: string) {
  const fp = path.join(from, 'config', 'routes.json');
  try {
    const data = JSON.parse((await readFile(fp)).toString());
    return data.routes.map((r: any) => (r.handler as string).split('.')[1]);
  } catch (_) {
    console.log(chalk.yellow`Couldn't infer permissions`)
    return [];
  }
}

/**
 * The API directory where controller data is stored.
 */
const API_DIRECTORY = '../api';

/**
 * Attempts to generate the passed controller list.
 * This function will attempt to infer the maximum information based
 * on API documentation.
 * @param list A list of controllers.
 */
export async function generateAll(list: string[]) {
  for (const dir of list) {
    const fp = path.join(API_DIRECTORY, dir);
    const docPath = path.join(fp, 'documentation', '1.0.0', `${dir}.json`);
    const docs = JSON.parse((await readFile(docPath)).toString());
    try {
      await mkdir(dir);
    } catch (_) {
      console.log(chalk.gray`  Already exists`);
    }
    const cData = pairs(docs.paths)
      .map(([url, v]) => {
        return pairs(v).map(([method, c]) => {
          let description = '';
          if (c.responses['200'] != null) {
            description = c.responses['200'].description || '';
          }
          return {
            path: url,
            method,
            description,
          } as ControllerData;
        });
      })
      .flat();
    console.log(chalk.gray`Inferring permissions from ${dir} routes...`)
    const perms = await inferPermissions(fp);
    const m = models[dir] || { name: 'unknown', attributes: [] };
    const out = await generateTest(dir, m, perms, cData);
    const outPath = path.join(dir, 'index.js');
    await writeFile(outPath, out);
    console.log(`âœ… Generated ${dir} test stub`);
  }
  console.log(chalk.greenBright`ðŸš€ Done! Check new tests!`);
}

/**
 * Generates the endpoint.
 */
export default async function endpoint() {
  console.log(
    chalk.gray`The generator will attempt to acquire the available API controllers...`
  );
  let toGenerate: string[] = [];
  try {
    const dirs = await getDirsOnly(API_DIRECTORY);
    const { included } = await inquirer.prompt([
      {
        type: 'checkbox',
        choices: dirs,
        name: 'included',
        message: 'Select the ones to include in the generation:',
        default: dirs.filter((dir) => {
          try {
            fs.statSync(path.join(dir, 'index.js'));
            return false;
          } catch (_) {
            return true;
          }
        }),
      },
    ]);
    toGenerate = included;
  } catch (err) {
    if (typeof err.code === 'undefined') {
      throw err;
    }
    console.log(chalk.red`Couldn't locate the API directory`);
    const { included } = await inquirer.prompt([
      {
        type: 'input',
        message: 'Enter a comma separated list of directories:',
      },
    ]);
    toGenerate = included.split(',').map((s: string) => s.trim());
  }
  // Generate all
  await getAllModels(await getDirsOnly(API_DIRECTORY));
  await generateAll(toGenerate);
}
